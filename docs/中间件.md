# 中间件详解

## 概述

gint 提供了三个实用的中间件，覆盖了 Web 应用开发中的常见需求：

- **访问日志（accesslog）** - 记录请求和响应信息
- **限流器（ratelimit）** - 防止接口被恶意调用
- **CORS** - 处理跨域请求

所有中间件都遵循 Gin 的中间件规范，可以灵活地应用到全局或特定路由。

## 访问日志中间件

### 功能特性

- 记录请求方法、路径、查询参数
- 记录客户端 IP、用户 ID
- 可选记录请求体和响应体
- 记录处理时间和状态码
- 记录错误信息
- 可配置最大记录长度

### 基本用法

```go
import "github.com/ink-code/gint/middlewares/accesslog"

r.Use(accesslog.NewBuilder(func(log *accesslog.AccessLog) {
    // 处理日志，可以输出到控制台、文件或日志服务
    fmt.Printf("[%s] %s %s - %d (%dms)\n", 
        log.IP, log.Method, log.Path, log.Status, log.Duration)
}).Build())
```

### 完整配置

```go
r.Use(accesslog.NewBuilder(func(log *accesslog.AccessLog) {
    // 自定义日志处理逻辑
    logEntry := map[string]any{
        "timestamp": time.Now().Unix(),
        "method":    log.Method,
        "path":      log.Path,
        "query":     log.Query,
        "ip":        log.IP,
        "user_id":   log.UserId,
        "status":    log.Status,
        "duration":  log.Duration,
    }
    
    if log.ReqBody != "" {
        logEntry["req_body"] = log.ReqBody
    }
    
    if log.RespBody != "" {
        logEntry["resp_body"] = log.RespBody
    }
    
    if log.Error != "" {
        logEntry["error"] = log.Error
    }
    
    // 输出到日志系统
    logger.Info(logEntry)
}).
    WithReqBody(true).           // 记录请求体
    WithRespBody(true).          // 记录响应体
    WithMaxBodyLength(2048).     // 最大记录长度（字节）
    Build())
```

### AccessLog 结构

```go
type AccessLog struct {
    Method   string // HTTP 方法
    Path     string // 请求路径
    Query    string // 查询参数
    IP       string // 客户端 IP
    UserId   string // 用户 ID（如果已登录）
    Status   int    // HTTP 状态码
    Duration int64  // 处理时间（毫秒）
    ReqBody  string // 请求体（如果启用）
    RespBody string // 响应体（如果启用）
    Error    string // 错误信息（如果有）
}
```

### 应用场景

#### 输出到文件

```go
import (
    "log"
    "os"
)

func main() {
    // 创建日志文件
    logFile, err := os.OpenFile("access.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        log.Fatal(err)
    }
    defer logFile.Close()
    
    logger := log.New(logFile, "", log.LstdFlags)
    
    r.Use(accesslog.NewBuilder(func(log *accesslog.AccessLog) {
        logger.Printf("[%s] %s %s - %d (%dms) User:%s\n",
            log.IP, log.Method, log.Path, log.Status, log.Duration, log.UserId)
    }).Build())
}
```

#### 发送到日志服务

```go
import "github.com/sirupsen/logrus"

r.Use(accesslog.NewBuilder(func(log *accesslog.AccessLog) {
    logrus.WithFields(logrus.Fields{
        "method":   log.Method,
        "path":     log.Path,
        "ip":       log.IP,
        "user_id":  log.UserId,
        "status":   log.Status,
        "duration": log.Duration,
    }).Info("API Request")
}).Build())
```

#### 仅记录错误请求

```go
r.Use(accesslog.NewBuilder(func(log *accesslog.AccessLog) {
    // 仅记录 4xx 和 5xx 错误
    if log.Status >= 400 {
        logger.Error(log)
    }
}).WithReqBody(true).WithRespBody(true).Build())
```

#### 排除特定路径

```go
func AccessLogMiddleware() gin.HandlerFunc {
    middleware := accesslog.NewBuilder(func(log *accesslog.AccessLog) {
        logger.Info(log)
    }).Build()
    
    return func(c *gin.Context) {
        // 排除健康检查接口
        if c.Request.URL.Path == "/health" || c.Request.URL.Path == "/ping" {
            c.Next()
            return
        }
        
        middleware(c)
    }
}
```

## 限流中间件

### 功能特性

- 基于 IP 的限流
- 基于用户 ID 的限流
- 自定义限流键
- 简单的内存限流器（固定窗口算法）
- 可扩展的限流器接口

### 基本用法

```go
import (
    "github.com/ink-code/gint/middlewares/ratelimit"
    "time"
)

// 创建限流器：每秒最多 10 个请求
limiter := ratelimit.NewSimpleLimiter(10, time.Second)

// 应用到全局
r.Use(ratelimit.NewBuilder(limiter).Build())
```

### 基于 IP 限流

```go
// 每个 IP 每秒最多 10 个请求
limiter := ratelimit.NewSimpleLimiter(10, time.Second)
r.Use(ratelimit.NewBuilder(limiter).WithIPKey().Build())
```

### 基于用户 ID 限流

```go
// 每个用户每秒最多 20 个请求
limiter := ratelimit.NewSimpleLimiter(20, time.Second)
r.Use(ratelimit.NewBuilder(limiter).WithUserIDKey().Build())
```

### 自定义限流键

```go
// 基于 API Key 限流
limiter := ratelimit.NewSimpleLimiter(100, time.Minute)
r.Use(ratelimit.NewBuilder(limiter).WithKeyFunc(func(ctx *gctx.Context) string {
    return ctx.GetHeader("X-API-Key")
}).Build())
```

### 应用到特定路由

```go
// 只对特定路由限流
limiter := ratelimit.NewSimpleLimiter(5, time.Minute)
rateLimitMiddleware := ratelimit.NewBuilder(limiter).WithIPKey().Build()

r.POST("/api/send-sms", rateLimitMiddleware, handler)
r.POST("/api/send-email", rateLimitMiddleware, handler)
```

### 不同接口不同限制

```go
// 严格限流的接口
strictLimiter := ratelimit.NewSimpleLimiter(5, time.Minute)
r.POST("/api/send-sms", 
    ratelimit.NewBuilder(strictLimiter).WithUserIDKey().Build(),
    handler,
)

// 宽松限流的接口
looseLimiter := ratelimit.NewSimpleLimiter(100, time.Minute)
r.GET("/api/list", 
    ratelimit.NewBuilder(looseLimiter).WithIPKey().Build(),
    handler,
)
```

### 自定义限流器

实现 `Limiter` 接口可以使用其他限流算法（如滑动窗口、令牌桶等）：

```go
type Limiter interface {
    // Limit 检查是否超过限流
    // key: 限流键
    // 返回 true 表示超过限流
    Limit(ctx context.Context, key string) (bool, error)
}
```

#### 使用 Redis 限流器示例

```go
import (
    "context"
    "time"
    "github.com/redis/go-redis/v9"
)

type RedisLimiter struct {
    client *redis.Client
    rate   int
    window time.Duration
}

func NewRedisLimiter(client *redis.Client, rate int, window time.Duration) *RedisLimiter {
    return &RedisLimiter{
        client: client,
        rate:   rate,
        window: window,
    }
}

func (l *RedisLimiter) Limit(ctx context.Context, key string) (bool, error) {
    // 使用 Redis INCR 和 EXPIRE 实现限流
    pipe := l.client.Pipeline()
    incr := pipe.Incr(ctx, "ratelimit:"+key)
    pipe.Expire(ctx, "ratelimit:"+key, l.window)
    
    _, err := pipe.Exec(ctx)
    if err != nil {
        return false, err
    }
    
    count := incr.Val()
    return count > int64(l.rate), nil
}

// 使用
rdb := redis.NewClient(&redis.Options{Addr: "localhost:6379"})
limiter := NewRedisLimiter(rdb, 100, time.Minute)
r.Use(ratelimit.NewBuilder(limiter).WithIPKey().Build())
```

### 自定义响应

```go
func RateLimitMiddleware() gin.HandlerFunc {
    limiter := ratelimit.NewSimpleLimiter(10, time.Second)
    
    return func(c *gin.Context) {
        ctx := &gctx.Context{Context: c}
        key := c.ClientIP()
        
        limited, err := limiter.Limit(c.Request.Context(), key)
        if err != nil {
            c.JSON(500, gin.H{"code": 500, "msg": "服务器错误"})
            c.Abort()
            return
        }
        
        if limited {
            c.JSON(429, gin.H{
                "code": 429,
                "msg":  "请求过于频繁，请稍后再试",
            })
            c.Abort()
            return
        }
        
        c.Next()
    }
}
```

## CORS 中间件

### 功能特性

- 配置允许的源、方法、头
- 支持凭证传输
- 预检请求处理
- 提供默认配置

### 默认配置

```go
import "github.com/ink-code/gint/middlewares/cors"

// 使用默认配置
// 允许所有源、常用方法和头
r.Use(cors.Default())
```

默认配置：
- **AllowOrigins**: `["*"]`
- **AllowMethods**: `["GET", "POST", "PUT", "DELETE", "OPTIONS"]`
- **AllowHeaders**: `["Origin", "Content-Type", "Authorization"]`
- **AllowCredentials**: `false`
- **MaxAge**: `86400`（24小时）

### 自定义配置

```go
r.Use(cors.New(cors.Config{
    AllowOrigins:     []string{"http://localhost:3000", "https://example.com"},
    AllowMethods:     []string{"GET", "POST", "PUT", "DELETE"},
    AllowHeaders:     []string{"Origin", "Content-Type", "Authorization", "X-Custom-Header"},
    ExposeHeaders:    []string{"Content-Length", "X-Total-Count"},
    AllowCredentials: true,
    MaxAge:           86400,
}))
```

### 配置说明

#### AllowOrigins

允许的源列表：

```go
// 允许所有源（不推荐用于生产环境）
AllowOrigins: []string{"*"}

// 允许特定源
AllowOrigins: []string{
    "http://localhost:3000",
    "https://app.example.com",
    "https://admin.example.com",
}
```

#### AllowMethods

允许的 HTTP 方法：

```go
AllowMethods: []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"}
```

#### AllowHeaders

允许的请求头：

```go
AllowHeaders: []string{
    "Origin",
    "Content-Type",
    "Authorization",
    "X-Requested-With",
    "X-API-Key",
}
```

#### ExposeHeaders

暴露给客户端的响应头：

```go
ExposeHeaders: []string{
    "Content-Length",
    "X-Total-Count",
    "X-Page-Number",
}
```

#### AllowCredentials

是否允许携带凭证（Cookie、HTTP 认证等）：

```go
AllowCredentials: true
```

**注意**：当 `AllowCredentials` 为 `true` 时，`AllowOrigins` 不能为 `["*"]`，必须指定具体的源。

#### MaxAge

预检请求的缓存时间（秒）：

```go
MaxAge: 86400 // 24小时
```

### 应用场景

#### 开发环境配置

```go
if os.Getenv("ENV") == "development" {
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"http://localhost:3000", "http://localhost:8080"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"*"},
        AllowCredentials: true,
    }))
}
```

#### 生产环境配置

```go
r.Use(cors.New(cors.Config{
    AllowOrigins: []string{
        "https://app.example.com",
        "https://www.example.com",
    },
    AllowMethods:     []string{"GET", "POST", "PUT", "DELETE"},
    AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
    AllowCredentials: true,
    MaxAge:           86400,
}))
```

#### 动态源验证

```go
func DynamicCORS() gin.HandlerFunc {
    return func(c *gin.Context) {
        origin := c.GetHeader("Origin")
        
        // 验证源是否在白名单中
        if isAllowedOrigin(origin) {
            c.Writer.Header().Set("Access-Control-Allow-Origin", origin)
            c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
            c.Writer.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE")
            c.Writer.Header().Set("Access-Control-Allow-Headers", "Origin, Content-Type, Authorization")
        }
        
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }
        
        c.Next()
    }
}

func isAllowedOrigin(origin string) bool {
    allowedOrigins := []string{
        "https://app.example.com",
        "https://admin.example.com",
    }
    
    for _, allowed := range allowedOrigins {
        if origin == allowed {
            return true
        }
    }
    
    return false
}
```

## 中间件组合使用

### 推荐的中间件顺序

```go
func main() {
    r := gin.Default()
    
    // 1. CORS（最先处理，处理预检请求）
    r.Use(cors.Default())
    
    // 2. 访问日志（记录所有请求）
    r.Use(accesslog.NewBuilder(logHandler).Build())
    
    // 3. 限流（防止恶意请求）
    limiter := ratelimit.NewSimpleLimiter(100, time.Minute)
    r.Use(ratelimit.NewBuilder(limiter).WithIPKey().Build())
    
    // 4. 自定义中间件
    r.Use(CustomMiddleware())
    
    // 5. 注册路由
    registerRoutes(r)
    
    r.Run(":8080")
}
```

### 分组应用中间件

```go
// 公开 API（宽松限流）
public := r.Group("/api/public")
{
    limiter := ratelimit.NewSimpleLimiter(100, time.Minute)
    public.Use(ratelimit.NewBuilder(limiter).WithIPKey().Build())
    
    public.GET("/articles", listArticles)
}

// 用户 API（基于用户限流）
user := r.Group("/api/user")
{
    limiter := ratelimit.NewSimpleLimiter(50, time.Minute)
    user.Use(ratelimit.NewBuilder(limiter).WithUserIDKey().Build())
    
    user.GET("/profile", getProfile)
    user.POST("/profile", updateProfile)
}

// 敏感操作（严格限流）
sensitive := r.Group("/api/sensitive")
{
    limiter := ratelimit.NewSimpleLimiter(5, time.Minute)
    sensitive.Use(ratelimit.NewBuilder(limiter).WithUserIDKey().Build())
    
    sensitive.POST("/send-sms", sendSMS)
    sensitive.POST("/change-password", changePassword)
}
```

## 最佳实践

### 1. 访问日志

- ✅ 生产环境记录到文件或日志服务
- ✅ 敏感接口记录请求体和响应体
- ✅ 设置合理的最大记录长度
- ❌ 不要记录密码等敏感信息

### 2. 限流

- ✅ 根据接口重要性设置不同的限流策略
- ✅ 敏感操作使用严格限流
- ✅ 生产环境使用 Redis 等分布式限流器
- ❌ 不要对所有接口使用相同的限流配置

### 3. CORS

- ✅ 生产环境指定具体的允许源
- ✅ 需要携带凭证时设置 `AllowCredentials: true`
- ✅ 只允许必要的方法和头
- ❌ 生产环境不要使用 `AllowOrigins: ["*"]`

### 4. 中间件顺序

- CORS → 访问日志 → 限流 → 自定义中间件 → 路由处理

## 总结

gint 提供的三个中间件覆盖了 Web 应用开发的核心需求。通过合理配置和组合使用，可以构建安全、高性能的 API 服务。所有中间件都提供了灵活的配置选项和扩展接口，可以根据实际需求进行定制。
