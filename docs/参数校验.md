# 参数校验

## 概述

gint 提供了强大的参数校验功能，采用**设计模式**（策略模式 + 建造者模式 + 组合模式），支持灵活的规则组合和扩展。

## 基本用法

### 推荐用法（设计模式版本）

```go
r.POST("/register", gint.B(func(ctx *gctx.Context, req RegisterReq) (gint.Result, error) {
    // 创建校验器构建器
    v := gint.NewValidatorBuilder()
    
    // 添加字段校验（链式调用）
    v.Field("用户名", req.Username).
        AddRule(gint.Required()).
        AddRule(gint.LengthRange(4, 20)).
        AddRule(gint.Pattern(`^[a-zA-Z0-9_]+$`, "只能包含字母、数字和下划线"))
    
    v.Field("密码", req.Password).
        AddRule(gint.Required()).
        AddRule(gint.MinLength(6))
    
    v.Field("邮箱", req.Email).
        AddRule(gint.Required()).
        AddRule(gint.Email())
    
    // 执行校验
    v.Validate()
    
    if !v.IsValid() {
        return gint.Error(v.GetFirstError()), nil
    }
    
    return gint.Success("注册成功", nil), nil
}))
```

### 使用预定义规则

```go
v := gint.NewValidatorBuilder()

// 使用预定义的组合规则
v.Field("用户名", req.Username).AddRule(gint.Username())
v.Field("密码", req.Password).AddRule(gint.Password())
v.Field("邮箱", req.Email).AddRule(gint.Email())
v.Field("手机号", req.Mobile).AddRule(gint.Mobile())

v.Validate()

if !v.IsValid() {
    return gint.Error(v.GetFirstError()), nil
}
```

## 校验规则

### 基础规则

#### Required - 必填

```go
v.Field("用户名", req.Username).AddRule(gint.Required())
// 错误信息：用户名不能为空
```

#### MinLength - 最小长度

```go
v.Field("用户名", req.Username).AddRule(gint.MinLength(4))
// 错误信息：用户名长度不能少于4个字符
```

#### MaxLength - 最大长度

```go
v.Field("用户名", req.Username).AddRule(gint.MaxLength(20))
// 错误信息：用户名长度不能超过20个字符
```

#### LengthRange - 长度范围

```go
v.Field("用户名", req.Username).AddRule(gint.LengthRange(4, 20))
// 错误信息：用户名长度必须在4到20个字符之间
```

### 格式规则

#### Email - 邮箱

```go
v.Field("邮箱", req.Email).AddRule(gint.Email())
// 错误信息：邮箱格式不正确
```

#### Mobile - 手机号

```go
v.Field("手机号", req.Mobile).AddRule(gint.Mobile())
// 错误信息：手机号格式不正确
// 支持中国大陆手机号：13x, 14x, 15x, 16x, 17x, 18x, 19x
```

#### URL - 网址

```go
v.Field("网站", req.Website).AddRule(gint.URL())
// 错误信息：网站格式不正确
```

#### Pattern - 自定义正则

```go
v.Field("邀请码", req.Code).
    AddRule(gint.Pattern(`^[A-Z]{2}\d{4}$`, "邀请码格式为2个大写字母+4个数字"))
```

**支持高级正则特性**（使用 regexp2）：
```go
// 正向环视：密码必须包含至少一个数字
v.Field("密码", req.Password).
    AddRule(gint.Pattern(`^(?=.*\d).{6,}$`, "密码必须包含至少一个数字"))

// 负向环视：用户名不能包含特殊字符
v.Field("用户名", req.Username).
    AddRule(gint.Pattern(`^(?!.*[!@#$%^&*]).+$`, "用户名不能包含特殊字符"))
```

### 范围规则

#### In - 枚举值

```go
v.Field("状态", req.Status).AddRule(gint.In("draft", "published", "archived"))
// 错误信息：状态的值不在允许的范围内
```

#### Range - 数值范围

```go
v.Field("年龄", req.Age).AddRule(gint.Range(18, 100))
// 错误信息：年龄必须在18到100之间
```

#### Equals - 相等性

```go
v.Field("确认密码", req.ConfirmPassword).AddRule(gint.Equals(req.Password))
// 错误信息：确认密码不一致
```

### 自定义规则

#### Custom - 自定义函数

```go
v.Field("密码", req.Password).
    AddRule(gint.Custom(func(value any) error {
        password, _ := value.(string)
        if !strings.ContainsAny(password, "!@#$%^&*") {
            return fmt.Errorf("必须包含特殊字符")
        }
        return nil
    }))
```

#### CustomCondition - 自定义条件

```go
v.Field("标签", len(req.Tags)).
    AddRule(gint.CustomCondition(len(req.Tags) <= 5, "数量不能超过5个"))
```

### 组合规则

#### And - 组合多个规则

```go
strongPasswordRule := gint.And(
    gint.Required(),
    gint.LengthRange(8, 20),
    gint.Pattern(`^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&]).+$`, 
        "必须包含大小写字母、数字和特殊字符"),
)

v.Field("密码", req.Password).AddRule(strongPasswordRule)
```

## 预定义规则组合

### Username - 用户名

```go
v.Field("用户名", req.Username).AddRule(gint.Username())
// 等同于：
// - Required()
// - LengthRange(4, 20)
// - Pattern(`^[a-zA-Z0-9_]+$`, "只能包含字母、数字和下划线")
```

### Password - 普通密码

```go
v.Field("密码", req.Password).AddRule(gint.Password())
// 等同于：
// - Required()
// - LengthRange(6, 20)
// - 必须包含字母和数字
```

### StrongPassword - 强密码

```go
v.Field("密码", req.Password).AddRule(gint.StrongPassword())
// 等同于：
// - Required()
// - LengthRange(8, 20)
// - 必须包含大小写字母、数字和特殊字符
```

### ChineseName - 中文姓名

```go
v.Field("姓名", req.Name).AddRule(gint.ChineseName())
// 等同于：
// - Required()
// - Pattern(`^[\p{Han}]{2,4}$`, "必须为2-4个汉字")
```

### IDCard - 身份证号

```go
v.Field("身份证号", req.IDCard).AddRule(gint.IDCard())
// 18位身份证号校验
```

## 便捷校验函数

除了构建器，还提供了便捷的校验函数：

```go
// 邮箱
if !gint.IsEmail(email) {
    return gint.Error("邮箱格式不正确"), nil
}

// 手机号
if !gint.IsMobile(mobile) {
    return gint.Error("手机号格式不正确"), nil
}

// URL
if !gint.IsURL(website) {
    return gint.Error("网站地址格式不正确"), nil
}

// 身份证号
if !gint.IsIDCard(idCard) {
    return gint.Error("身份证号格式不正确"), nil
}

// 用户名
if !gint.IsUsername(username) {
    return gint.Error("用户名格式不正确"), nil
}

// 密码强度
if !gint.IsPassword(password) {
    return gint.Error("密码必须包含字母和数字"), nil
}

if !gint.IsStrongPassword(password) {
    return gint.Error("密码强度不足"), nil
}

// 中文姓名
if !gint.IsChineseName(name) {
    return gint.Error("姓名格式不正确"), nil
}

// 字符类型
if !gint.IsNumeric(code) {
    return gint.Error("验证码必须为数字"), nil
}

if !gint.IsAlpha(value) {
    return gint.Error("只能包含字母"), nil
}

if !gint.IsAlphaNumeric(value) {
    return gint.Error("只能包含字母和数字"), nil
}
```

## 完整示例

### 用户注册

```go
type RegisterReq struct {
    Username        string `json:"username" binding:"required"`
    Password        string `json:"password" binding:"required"`
    ConfirmPassword string `json:"confirm_password" binding:"required"`
    Email           string `json:"email" binding:"required"`
    Mobile          string `json:"mobile"`
}

r.POST("/register", gint.B(func(ctx *gctx.Context, req RegisterReq) (gint.Result, error) {
    v := gint.NewValidatorBuilder()
    
    // 用户名校验
    v.Field("用户名", req.Username).AddRule(gint.Username())
    
    // 密码校验
    v.Field("密码", req.Password).AddRule(gint.Password())
    
    // 确认密码
    v.Field("确认密码", req.ConfirmPassword).AddRule(gint.Equals(req.Password))
    
    // 邮箱校验
    v.Field("邮箱", req.Email).AddRule(gint.Email())
    
    // 手机号校验（可选）
    if req.Mobile != "" {
        v.Field("手机号", req.Mobile).AddRule(gint.Mobile())
    }
    
    v.Validate()
    
    if !v.IsValid() {
        return gint.Error(v.GetFirstError()), nil
    }
    
    // 创建用户...
    return gint.Success("注册成功", nil), nil
}))
```

### 创建文章

```go
type CreateArticleReq struct {
    Title    string   `json:"title" binding:"required"`
    Content  string   `json:"content" binding:"required"`
    Tags     []string `json:"tags"`
    Status   string   `json:"status"`
    CoverURL string   `json:"cover_url"`
}

r.POST("/articles", gint.BS(func(ctx *gctx.Context, req CreateArticleReq, sess session.Session) (gint.Result, error) {
    v := gint.NewValidatorBuilder()
    
    v.Field("标题", req.Title).
        AddRule(gint.Required()).
        AddRule(gint.LengthRange(5, 100))
    
    v.Field("内容", req.Content).
        AddRule(gint.Required()).
        AddRule(gint.MinLength(10))
    
    v.Field("标签", len(req.Tags)).
        AddRule(gint.CustomCondition(len(req.Tags) <= 5, "数量不能超过5个"))
    
    v.Field("状态", req.Status).
        AddRule(gint.In("draft", "published"))
    
    if req.CoverURL != "" {
        v.Field("封面", req.CoverURL).AddRule(gint.URL())
    }
    
    v.Validate()
    
    if !v.IsValid() {
        return gint.Error(v.GetFirstError()), nil
    }
    
    // 创建文章...
    return gint.Success("创建成功", nil), nil
}))
```

## 扩展自定义规则

### 实现 ValidationRule 接口

```go
// 定义银行卡号规则
type BankCardRule struct{}

func (r *BankCardRule) Validate(value any) error {
    cardNo, ok := value.(string)
    if !ok || cardNo == "" {
        return nil
    }
    
    // Luhn 算法校验
    if !luhnCheck(cardNo) {
        return fmt.Errorf("格式不正确")
    }
    
    return nil
}

// 创建构造函数
func BankCard() gint.ValidationRule {
    return &BankCardRule{}
}

// 使用
v.Field("银行卡号", req.BankCard).AddRule(BankCard())
```

## 错误处理

### 获取第一个错误

```go
if !v.IsValid() {
    return gint.Error(v.GetFirstError()), nil
}
```

### 获取所有错误

```go
if !v.IsValid() {
    errors := v.GetErrors()
    return gint.Error(strings.Join(errors, "；")), nil
}
```

### 获取错误字符串

```go
if !v.IsValid() {
    // 自动用分号连接所有错误
    return gint.Error(v.GetErrorString()), nil
}
```

## 最佳实践

### 1. 提取校验逻辑

```go
func validateRegisterReq(req RegisterReq) *gint.ValidatorBuilder {
    v := gint.NewValidatorBuilder()
    v.Field("用户名", req.Username).AddRule(gint.Username())
    v.Field("密码", req.Password).AddRule(gint.Password())
    v.Field("邮箱", req.Email).AddRule(gint.Email())
    return v.Validate()
}

// 使用
v := validateRegisterReq(req)
if !v.IsValid() {
    return gint.Error(v.GetFirstError()), nil
}
```

### 2. 创建领域规则

```go
func ArticleTitle() gint.ValidationRule {
    return gint.And(
        gint.Required(),
        gint.LengthRange(5, 100),
    )
}
```

### 3. 规则复用

```go
// 预定义常用规则
var (
    usernameRule = gint.Username()
    passwordRule = gint.Password()
    emailRule    = gint.Email()
)

// 复用
v.Field("用户名", req.Username).AddRule(usernameRule)
```

### 4. 清晰的错误消息

```go
// ✅ 推荐：清晰具体
v.Field("密码", req.Password).
    AddRule(gint.Custom(func(value any) error {
        // 返回清晰的错误消息
        return fmt.Errorf("密码长度至少8位，且必须包含大小写字母、数字和特殊字符")
    }))

// ❌ 不推荐：模糊笼统
v.Field("密码", req.Password).
    AddRule(gint.Custom(func(value any) error {
        return fmt.Errorf("密码不符合要求")
    }))
```

## 设计模式

gint 的校验器采用了多种设计模式，使其更加灵活、可扩展和易于维护：

### 1. 策略模式（Strategy Pattern）

**定义**: ValidationRule 接口，每个规则都是独立的策略

```go
// ValidationRule 校验规则接口
type ValidationRule interface {
    Validate(value any) error
}
```

**优势**:
- ✅ 每个校验规则都是独立的策略
- ✅ 易于添加新的校验规则
- ✅ 规则之间互不影响

**示例**:
```go
// 必填规则
type RequiredRule struct{}

func (r *RequiredRule) Validate(value any) error {
    if value == nil || value == "" {
        return fmt.Errorf("不能为空")
    }
    return nil
}
```

### 2. 建造者模式（Builder Pattern）

**定义**: ValidatorBuilder，链式调用构建校验逻辑

```go
// ValidatorBuilder 校验器构建器
type ValidatorBuilder struct {
    validators []*FieldValidator
    errors     []string
}

// Field 添加字段校验
func (vb *ValidatorBuilder) Field(fieldName string, value any) *FieldValidator {
    fv := NewFieldValidator(fieldName, value)
    vb.validators = append(vb.validators, fv)
    return fv
}
```

**优势**:
- ✅ 链式调用，API 优雅
- ✅ 逐步构建复杂的校验逻辑
- ✅ 分离构建过程和表示

### 3. 组合模式（Composite Pattern）

**定义**: CompositeRule，组合多个规则

```go
// CompositeRule 组合规则
type CompositeRule struct {
    rules []ValidationRule
}

func (r *CompositeRule) Validate(value any) error {
    for _, rule := range r.rules {
        if err := rule.Validate(value); err != nil {
            return err
        }
    }
    return nil
}

// And 组合多个规则
func And(rules ...ValidationRule) ValidationRule {
    return &CompositeRule{rules: rules}
}
```

**优势**:
- ✅ 将多个规则组合成一个规则
- ✅ 统一的接口处理单个和组合规则
- ✅ 易于创建复杂的校验逻辑

**使用示例**:
```go
// 定义强密码规则（组合多个规则）
strongPasswordRule := gint.And(
    gint.Required(),
    gint.LengthRange(8, 20),
    gint.Custom(func(value any) error {
        str, _ := value.(string)
        if !gint.IsStrongPassword(str) {
            return fmt.Errorf("必须包含大小写字母、数字和特殊字符")
        }
        return nil
    }),
)

v.Field("密码", req.Password).AddRule(strongPasswordRule)
```

### 设计原则

#### 开闭原则（OCP）
- **对扩展开放**: 可以轻松添加新规则
- **对修改关闭**: 不需要修改现有代码

#### 单一职责原则（SRP）
- 每个规则只负责一种校验
- `EmailRule` 只负责邮箱校验
- `MobileRule` 只负责手机号校验
- `RequiredRule` 只负责必填校验

#### 依赖倒置原则（DIP）
- 依赖抽象（ValidationRule 接口），不依赖具体实现
- `FieldValidator` 依赖 `ValidationRule` 接口

#### 组合优于继承
- 使用组合模式组合多个规则，而不是继承

## 总结

gint 的参数校验功能：

- ✅ **设计模式** - 策略+建造者+组合模式
- ✅ **链式调用** - 优雅的 API 设计
- ✅ **丰富的规则** - 覆盖常见校验场景
- ✅ **便捷函数** - 快速校验常用格式
- ✅ **灵活扩展** - 支持自定义校验逻辑
- ✅ **高级正则** - 支持 regexp2 的所有特性
- ✅ **清晰的错误** - 友好的错误提示

使用 gint 的校验功能，让参数验证更加简单、规范和强大！
