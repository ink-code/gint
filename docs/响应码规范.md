# 响应码规范

## 概述

gint 使用统一的响应码规范，所有 API 响应都遵循以下格式：

```json
{
    "code": 0,
    "msg": "成功",
    "data": {}
}
```

## 响应码定义

| Code | 含义 | 说明 |
|------|------|------|
| **0** | 成功 | 请求处理成功 |
| **1** | 警告 | 请求处理成功，但有需要注意的信息 |
| **2** | 错误 | 请求处理失败 |

> 💡 如果业务需要更细分的错误码，可以自定义扩展（如 100-199 表示参数错误，200-299 表示认证错误等）

### 使用示例

```go
// 成功（使用默认消息）
return gint.Success("", data)
// 等同于
return gint.Result{Code: 0, Msg: "成功", Data: data}, nil

// 成功（自定义消息）
return gint.Success("登录成功", data)
// 等同于
return gint.Result{Code: 0, Msg: "登录成功", Data: data}, nil

// 警告
return gint.Warning("数据已存在，已跳过", data)
// 等同于
return gint.Result{Code: 1, Msg: "数据已存在，已跳过", Data: data}, nil

// 错误
return gint.Error("操作失败")
// 等同于
return gint.Result{Code: 2, Msg: "操作失败"}, nil
```

## 完整示例

### 用户注册

```go
type RegisterReq struct {
    Username string `json:"username" binding:"required"`
    Password string `json:"password" binding:"required"`
    Email    string `json:"email" binding:"required,email"`
}

r.POST("/register", gint.B(func(ctx *gctx.Context, req RegisterReq) (gint.Result, error) {
    // 1. 检查用户名是否已存在
    if userExists(req.Username) {
        return gint.Error("用户名已被使用"), nil
    }
    
    // 2. 创建用户
    user, err := createUser(req)
    if err != nil {
        return gint.Error("创建用户失败"), err
    }
    
    // 3. 成功
    return gint.Success("注册成功", map[string]any{
        "user_id": user.ID,
        "username": user.Username,
    }), nil
}))
```

### 用户登录

```go
r.POST("/login", gint.B(func(ctx *gctx.Context, req LoginReq) (gint.Result, error) {
    // 1. 验证用户名密码
    user, err := validateUser(req.Username, req.Password)
    if err != nil {
        return gint.Error("用户名或密码错误"), nil
    }
    
    // 2. 创建 Session
    sess, err := session.NewSession(ctx, user.ID,
        map[string]string{"role": user.Role},
        map[string]any{"login_time": time.Now().Unix()},
    )
    if err != nil {
        return gint.Error("创建会话失败"), err
    }
    
    // 3. 成功
    return gint.Success("登录成功", map[string]any{
        "user_id": sess.Claims().UserId,
        "role": sess.Claims().Data["role"],
    }), nil
}))
```

### 获取用户信息

```go
r.GET("/users/:id", gint.W(func(ctx *gctx.Context) (gint.Result, error) {
    userId := ctx.Param("id").StringOr("")
    
    // 1. 查询用户
    user, err := getUserById(userId)
    if err != nil {
        if errors.Is(err, ErrUserNotFound) {
            return gint.Error("用户不存在"), nil
        }
        return gint.Error("查询失败"), err
    }
    
    // 2. 成功
    return gint.Success("", user), nil
}))
```

### 更新用户信息

```go
r.PUT("/users/:id", gint.BS(func(ctx *gctx.Context, req UpdateUserReq, sess session.Session) (gint.Result, error) {
    userId := ctx.Param("id").StringOr("")
    currentUserId := sess.Claims().UserId
    
    // 1. 权限检查
    if userId != currentUserId && sess.Claims().Data["role"] != "admin" {
        return gint.Error("无权修改其他用户信息"), nil
    }
    
    // 2. 更新用户
    if err := updateUser(userId, req); err != nil {
        return gint.Error("更新失败"), err
    }
    
    // 3. 成功
    return gint.Success("更新成功", nil), nil
}))
```

### 批量操作（带警告）

```go
r.POST("/users/batch-import", gint.B(func(ctx *gctx.Context, req BatchImportReq) (gint.Result, error) {
    successCount := 0
    skipCount := 0
    failCount := 0
    
    for _, user := range req.Users {
        if userExists(user.Username) {
            skipCount++
            continue
        }
        
        if err := createUser(user); err != nil {
            failCount++
        } else {
            successCount++
        }
    }
    
    // 根据结果返回不同的响应
    if failCount > 0 {
        return gint.Error(fmt.Sprintf("导入失败：成功 %d，跳过 %d，失败 %d", 
            successCount, skipCount, failCount)), nil
    }
    
    if skipCount > 0 {
        return gint.Warning(fmt.Sprintf("部分数据已存在：成功 %d，跳过 %d", 
            successCount, skipCount), map[string]int{
            "success": successCount,
            "skip": skipCount,
        }), nil
    }
    
    return gint.Success("导入成功", map[string]int{
        "success": successCount,
    }), nil
}))
```

## 客户端处理

### JavaScript 示例

```javascript
async function apiRequest(url, options) {
    const response = await fetch(url, options);
    const result = await response.json();
    
    switch (result.code) {
        case 0: // 成功
            console.log('操作成功', result.data);
            return result.data;
            
        case 1: // 警告
            console.warn('警告', result.msg);
            // 显示警告提示
            showWarning(result.msg);
            return result.data;
            
        case 2: // 错误
            console.error('错误', result.msg);
            // 显示错误提示
            showError(result.msg);
            throw new Error(result.msg);
            
        default: // 扩展错误码
            if (result.code >= 200 && result.code < 300) {
                // 认证错误，跳转登录
                window.location.href = '/login';
            } else {
                // 其他错误
                showError(result.msg);
            }
            throw new Error(result.msg);
    }
}

// 使用示例
try {
    const user = await apiRequest('/api/users/123', {
        headers: { 'Authorization': token }
    });
    console.log('用户信息', user);
} catch (error) {
    console.error('请求失败', error);
}
```

### 统一错误处理

```javascript
// Axios 拦截器
axios.interceptors.response.use(
    response => {
        const result = response.data;
        
        // 成功
        if (result.code === 0) {
            return result.data;
        }
        
        // 警告
        if (result.code === 1) {
            showWarning(result.msg);
            return result.data;
        }
        
        // 错误
        if (result.code === 2) {
            showError(result.msg);
            return Promise.reject(new Error(result.msg));
        }
        
        // 认证错误
        if (result.code >= 200 && result.code < 300) {
            if (result.code === 201) { // Token 过期
                // 尝试刷新 Token
                return refreshTokenAndRetry(response.config);
            }
            // 其他认证错误，跳转登录
            window.location.href = '/login';
            return Promise.reject(new Error(result.msg));
        }
        
        // 其他错误
        showError(result.msg);
        return Promise.reject(new Error(result.msg));
    },
    error => {
        showError('网络错误');
        return Promise.reject(error);
    }
);
```

## 自定义错误码

你可以根据业务需求定义自己的错误码：

```go
// 在你的项目中定义
const (
    // 订单相关 (600-699)
    CodeOrderNotFound    = 600
    CodeOrderCancelled   = 601
    CodeOrderPaid        = 602
    
    // 支付相关 (700-799)
    CodePaymentFailed    = 700
    CodeInsufficientBalance = 701
)

// 使用
r.POST("/orders/:id/pay", gint.BS(func(ctx *gctx.Context, req PayReq, sess session.Session) (gint.Result, error) {
    orderId := ctx.Param("id").StringOr("")
    
    // 检查订单
    order, err := getOrder(orderId)
    if err != nil {
        return gint.ErrorWithCode(CodeOrderNotFound, "订单不存在"), nil
    }
    
    // 检查余额
    if getBalance(sess.Claims().UserId) < order.Amount {
        return gint.ErrorWithCode(CodeInsufficientBalance, "余额不足"), nil
    }
    
    // 支付
    if err := payOrder(order); err != nil {
        return gint.ErrorWithCode(CodePaymentFailed, "支付失败"), err
    }
    
    return gint.Success(order), nil
}))
```

## 最佳实践

### 1. 使用常量

```go
// ✅ 推荐：使用常量
return gint.ErrorWithCode(gint.CodeNotFound, "用户不存在"), nil

// ❌ 不推荐：硬编码
return gint.Result{Code: 300, Msg: "用户不存在"}, nil
```

### 2. 提供清晰的错误消息

```go
// ✅ 推荐：清晰的错误消息
return gint.ErrorWithCode(gint.CodeParamInvalid, "邮箱格式不正确，请输入有效的邮箱地址"), nil

// ❌ 不推荐：模糊的错误消息
return gint.ErrorWithCode(gint.CodeParamInvalid, "参数错误"), nil
```

### 3. 区分业务错误和系统错误

```go
// 业务错误：返回 Result + nil error
if user == nil {
    return gint.ErrorWithCode(gint.CodeNotFound, "用户不存在"), nil
}

// 系统错误：返回 Result + error
if err := db.Save(&user).Error; err != nil {
    return gint.ErrorWithCode(gint.CodeDatabaseError, "保存失败"), err
}
```

### 4. 合理使用警告

```go
// 操作成功但有需要注意的信息
if duplicateCount > 0 {
    return gint.Warning(
        fmt.Sprintf("导入成功，跳过 %d 条重复数据", duplicateCount),
        result,
    ), nil
}
```

## 响应码对照表

| 范围 | 类型 | 说明 |
|------|------|------|
| 0 | 成功 | 请求处理成功 |
| 1 | 警告 | 成功但有注意事项 |
| 2 | 错误 | 请求处理失败 |
| 100-199 | 参数错误 | 请求参数相关错误 |
| 200-299 | 认证错误 | 身份认证相关错误 |
| 300-399 | 资源错误 | 资源操作相关错误 |
| 400-499 | 业务错误 | 业务逻辑相关错误 |
| 500-599 | 系统错误 | 系统内部错误 |
| 600+ | 自定义 | 业务自定义错误码 |

## 总结

gint 的响应码规范：

- ✅ **0 = 成功** - 请求处理成功
- ✅ **1 = 警告** - 成功但有需要注意的信息
- ✅ **2 = 错误** - 请求处理失败
- ✅ **扩展错误码** - 更精确的错误类型
- ✅ **统一格式** - 所有响应格式一致
- ✅ **易于扩展** - 可自定义业务错误码

使用统一的响应码规范，让前后端协作更加顺畅！
