# 活跃连接限制中间件

## 概述

活跃连接限制中间件用于限制同时处理的请求数量，防止服务器过载。与限流器（ratelimit）不同，活跃连接限制关注的是**同时进行中的请求数**，而不是单位时间内的请求数。

## 使用场景

- **保护服务器资源** - 防止过多并发请求导致服务器崩溃
- **数据库连接保护** - 限制同时访问数据库的连接数
- **长连接服务** - 如 WebSocket、SSE 等长连接场景
- **资源密集型接口** - 如文件上传、视频处理等

## 基本用法

```go
import "github.com/ink-code/gint/middlewares/activelimit"

func main() {
    r := gin.Default()
    
    // 限制最多同时处理 100 个请求
    r.Use(activelimit.NewBuilder(100).Build())
    
    r.GET("/api/data", handler)
    r.Run(":8080")
}
```

## 工作原理

1. 请求到达时，活跃连接计数 +1
2. 检查是否超过最大限制
3. 如果超过限制，返回 429 状态码
4. 如果未超过限制，继续处理请求
5. 请求结束后，活跃连接计数 -1

## 应用到特定路由

```go
// 只对特定路由限制
activeLimit := activelimit.NewBuilder(50).Build()

r.POST("/api/upload", activeLimit, uploadHandler)
r.POST("/api/process", activeLimit, processHandler)
```

## 不同路由不同限制

```go
// 普通接口：最多 100 个并发
normalLimit := activelimit.NewBuilder(100).Build()
r.GET("/api/list", normalLimit, listHandler)

// 资源密集型接口：最多 10 个并发
heavyLimit := activelimit.NewBuilder(10).Build()
r.POST("/api/upload", heavyLimit, uploadHandler)
r.POST("/api/video/process", heavyLimit, processVideoHandler)
```

## 与限流器的区别

| 特性 | 活跃连接限制 | 限流器 |
|------|------------|--------|
| **限制对象** | 同时进行中的请求数 | 单位时间内的请求数 |
| **适用场景** | 长连接、资源密集型 | 防止恶意刷接口 |
| **计数方式** | 请求开始 +1，结束 -1 | 固定时间窗口内计数 |
| **典型值** | 10-1000 | 10-10000/分钟 |

## 实际示例

### 文件上传限制

```go
func main() {
    r := gin.Default()
    
    // 文件上传最多同时 5 个
    uploadLimit := activelimit.NewBuilder(5).Build()
    
    r.POST("/upload", uploadLimit, func(c *gin.Context) {
        file, _ := c.FormFile("file")
        // 处理文件上传...
        c.JSON(200, gin.H{"message": "上传成功"})
    })
    
    r.Run(":8080")
}
```

### SSE 长连接限制

```go
func main() {
    r := gin.Default()
    
    // SSE 连接最多 1000 个
    sseLimit := activelimit.NewBuilder(1000).Build()
    
    r.GET("/events", sseLimit, gint.W(func(ctx *gctx.Context) (gint.Result, error) {
        eventCh := ctx.EventStream()
        
        go func() {
            defer close(eventCh)
            for i := 0; i < 100; i++ {
                eventCh <- []byte(fmt.Sprintf("data: %d\n\n", i))
                time.Sleep(time.Second)
            }
        }()
        
        return gint.Result{}, gint.ErrNoResponse
    }))
    
    r.Run(":8080")
}
```

### 分组限制

```go
func main() {
    r := gin.Default()
    
    // 普通 API
    api := r.Group("/api")
    api.Use(activelimit.NewBuilder(200).Build())
    {
        api.GET("/users", listUsers)
        api.GET("/articles", listArticles)
    }
    
    // 管理后台 API
    admin := r.Group("/admin")
    admin.Use(activelimit.NewBuilder(50).Build())
    {
        admin.POST("/users", createUser)
        admin.DELETE("/users/:id", deleteUser)
    }
    
    // 资源密集型 API
    heavy := r.Group("/heavy")
    heavy.Use(activelimit.NewBuilder(10).Build())
    {
        heavy.POST("/upload", uploadFile)
        heavy.POST("/export", exportData)
    }
    
    r.Run(":8080")
}
```

## 监控和调优

### 如何确定合适的限制值？

1. **压力测试** - 使用工具如 Apache Bench、wrk 进行压力测试
2. **监控指标** - 观察服务器 CPU、内存、数据库连接数等
3. **逐步调整** - 从保守值开始，逐步增加到合适的值

```bash
# 使用 wrk 进行压力测试
wrk -t12 -c400 -d30s http://localhost:8080/api/data

# 观察服务器资源使用情况
top
htop
```

### 典型配置参考

```go
// Web 应用
normalAPI := activelimit.NewBuilder(500).Build()

// 文件上传
uploadAPI := activelimit.NewBuilder(20).Build()

// 数据导出
exportAPI := activelimit.NewBuilder(5).Build()

// SSE/WebSocket
longConnection := activelimit.NewBuilder(1000).Build()

// 数据库密集型操作
dbHeavy := activelimit.NewBuilder(50).Build()
```

## 注意事项

### 1. 与限流器配合使用

建议同时使用活跃连接限制和限流器：

```go
r.Use(cors.Default())
r.Use(accesslog.NewBuilder(logHandler).Build())
r.Use(ratelimit.NewBuilder(limiter).WithIPKey().Build())  // 限流
r.Use(activelimit.NewBuilder(100).Build())                // 活跃连接限制
```

### 2. 避免设置过小

如果设置过小，可能导致正常用户也无法访问：

```go
// ❌ 不推荐：太小了
r.Use(activelimit.NewBuilder(1).Build())

// ✅ 推荐：根据实际情况设置
r.Use(activelimit.NewBuilder(100).Build())
```

### 3. 考虑服务器性能

限制值应该根据服务器性能来设置：

- **低配服务器**（1核2G）：50-100
- **中配服务器**（2核4G）：100-300
- **高配服务器**（4核8G+）：300-1000

### 4. 长连接场景特殊处理

对于 SSE、WebSocket 等长连接，需要设置更大的限制：

```go
// 普通 HTTP 请求
r.GET("/api/data", activelimit.NewBuilder(100).Build(), handler)

// 长连接
r.GET("/events", activelimit.NewBuilder(1000).Build(), sseHandler)
```

## 最佳实践

1. **分层限制** - 全局限制 + 路由组限制 + 特定路由限制
2. **监控告警** - 监控活跃连接数，设置告警阈值
3. **优雅降级** - 超过限制时返回友好的错误信息
4. **压力测试** - 上线前进行充分的压力测试
5. **动态调整** - 根据实际运行情况动态调整限制值

## 总结

活跃连接限制中间件是保护服务器资源的重要手段，特别适合处理长连接和资源密集型操作。合理配置活跃连接限制，可以有效防止服务器过载，提高系统的稳定性和可用性。
